import sys
import math
import cv2
import numpy as np
from ChessBoardDetector import filter_grids as fg
from ChessBoardDetector import HarrisCornerDetection as hcd
from ChessBoardDetector import cv_filter_groups as cvfg
from sklearn.cluster import DBSCAN
from scipy.optimize import curve_fit
from collections import Counter


def flatten_lines(lines):
    """Helper function to flatten grouped overlapping lines"""
    flat = []
    for l in lines:
        for x in l:
            flat.append(x)
    return flat


def put_lines(lines, image, color, thickness=2):
    if len(lines) != 0:
        for rho, theta in lines:
            points = get_line(rho,theta)
            # Display line using openCV (GPT)
            cv2.line(image, points[0], points[1], color=color, thickness=thickness)


def line_midpoint(line, image_shape):
    """
    To-Do
    :param line:
    :param image_shape:
    :return:
    """
    print("x")


def mean_lines(line1, line2):

    """GPT suggested to double theta then use trig functions to get circular theta means"""
    rho1, theta1 = line1
    rho2, theta2 = line2
    rho1, rho2 = abs(rho1), abs(rho2)
    mean_rho = (rho1 + rho2) / 2
    x = np.cos(2 * np.array([theta1, theta2]))
    y = np.sin(2 * np.array([theta1, theta2]))
    mean_theta = 0.5 * np.arctan2(np.mean(y), np.mean(x))
    return mean_rho, mean_theta % np.pi


def normalize_rho(lines):
    for i, l in enumerate(lines):
        rho, theta = l
        if rho < 0:
            rho *= -1
            theta += np.pi
            theta = theta % (2 * np.pi)
            lines[i] = [rho, theta]
    return lines


def circle_theta(theta):
    """
    Adds 45 degree to theta, mainly used on directions being 0, 180
    :param theta:
    :return:
    """
    return (theta + np.pi/4) % np.pi


def slope_from_theta(theta, max):
    """
    The max slope for the lines would be the height of the image
    :param theta: Theta to convert to slope
    :param max: The height of the image
    :return: Slope of the line cooresponding to the theta inputted
    """
    if np.isclose(np.sin(theta), 0):
        return max
    return -np.cos(theta) / np.sin(theta)


def show_images(image):
    # Display the result (GPT)
    cv2.imshow("",image)
    cv2.waitKey(0)
    cv2.destroyAllWindows()


def get_line(rho, theta):
    """
    Closest point of the found line formula:
    (x0,y0) = (ρ * cos(θ), ρ * sin(θ))

    Since cos = adj/hypt in respect of x axis, cos(theta) * rho (hypt) = x value
    Same applies to sin, sin(theta) * rho = y value
    """
    # (GPT)
    a = np.cos(theta)
    b = np.sin(theta)
    x0 = a * rho
    y0 = b * rho
    # To expand the line, totalling to 3000 pixel length
    x1 = int(x0 + 2000 * (-b))
    y1 = int(y0 + 2000 * (a))
    x2 = int(x0 - 2000 * (-b))
    y2 = int(y0 - 2000 * (a))
    return [(x1, y1), (x2, y2)]


def polar_theta(point):
    """
    Get the polar coordinate theta value from two lines
    point is a [[x1, y1, x2, y2]] type argument

    """
    x1, y1, x2, y2 = point[0]
    # Formula from GPT
    return np.arctan2(y2 - y1, x2 - x1) % np.pi


def polar_rho(point, theta):
    x1, y1, x2, y2 = point[0]
    # Formula from GPT
    return x1 * np.cos(theta) + y1 * np.sin(theta)


def unpack_hough(lines):
    """
    Unpacks the houghline 3D array into 2D array of [rho,theta] values
    """
    if lines is not None:
        return [[rho_theta[0][0], rho_theta[0][1]] for rho_theta in lines]
        # or using numpy
        # unpacked = lines[:, 0, :]  # shape (N, 2)
    else:
        return []


def orthogonal_gap(line1, line2):
    """
    Perpendicular spacing = Δρ/cos(θ)
    Update:
    Really only works when the thetas are similar to each other
    :param line1:
    :param line2:
    :return:
    """
    r1, t1 = line1
    r2, t2 = line2
    delta_rho = abs(r2 - r1)
    mean_theta = (t1 + t2) / 2

    denom = math.cos(mean_theta)
    if denom > 0.0001:
        return delta_rho / denom
    else:
        return delta_rho


def points_between_lines(points, line1, line2):
    """
    This function is completely generated by GPT
    This is in order to get corners in between to lines for interpolation
    """

    def signed_distance(x, y, a, b, c):
        return (a * x + b * y + c) / np.sqrt(a ** 2 + b ** 2)

    def hough_to_line_params(rho, theta):
        # ax + by + c = 0
        a = np.cos(theta)
        b = np.sin(theta)
        c = -rho
        return a, b, c

    a1, b1, c1 = hough_to_line_params(*line1)
    a2, b2, c2 = hough_to_line_params(*line2)

    pts = np.array(points)
    x = pts[:, 0]
    y = pts[:, 1]

    d1 = signed_distance(x, y, a1, b1, c1)
    d2 = signed_distance(x, y, a2, b2, c2)

    # Sign flip means point lies between the two lines
    mask = (d1 * d2 < 0)

    return pts[mask]


def line_to_rho_theta(m, b):
    """
    GPT helper function to convert to houghline format
    :param m:
    :param b:
    :return:
    """
    # Convert slope-intercept to normal form (rho, theta)
    # Line: y = m * x + b  → Ax + By + C = 0, where A = -m, B = 1, C = -b
    A = -m
    B = 1
    C = -b

    theta = np.arctan2(B, A)         # angle of the normal vector
    rho = -C / np.sqrt(A**2 + B**2)  # distance to origin

    return rho, theta

"""
Functions below were taken from stack overflow by user:
https://stackoverflow.com/users/18078/david-leppik

stack overflow prompt:
https://stackoverflow.com/questions/22057940/
how-to-get-coordinates-of-end-points-in-cartesian-coordinate-system-and-the-corr
"""
def y_for_line(x, r, theta):
    if theta == 0:
        return None
    return (r - (x * np.cos(theta))) / np.sin(theta)


def x_for_line(y, r, theta):
    cos_theta = np.cos(theta)
    if cos_theta == 0:
        return None
    return (r - (y * np.sin(theta))) / cos_theta